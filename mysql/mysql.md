
> - 整理参见 [关于MySQL，你未必知道的](https://mp.weixin.qq.com/s/pWHCieOwAdCrz8cauduWlQ)
> - 推荐阅读 [关于MySQL内核，一定要知道的](https://mp.weixin.qq.com/s/tmkRAmc1M_Y23ynduBeP3Q)
> - [新手MySQL工程师必备命令速查手册](https://mp.weixin.qq.com/s?__biz=MzI4NTA1MDEwNg==&mid=2650767653&idx=1&sn=8d61b92ce782fca748822b5a314d1cb6&chksm=f3f934b0c48ebda6a01cbc9316bd70c87683d72014e965de61a9901f166c2a1617be7ba13878&scene=21#wechat_redirect)
> - [MySQL设计和开发规范](https://mp.weixin.qq.com/s/9HIsYhL4AqU35JwWY3bXCA)


## 19-04-30 更新
### 小米 MySQL

* 启发式规则建议 ： https://github.com/XiaoMi/soar/blob/master/doc/heuristic.md
* 索引优化建议 ： https://github.com/XiaoMi/soar/blob/master/doc/indexing.md

----

## 规范
参考：[58到家MySQL军规升级版](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961030&idx=1&sn=73a04dabca409c1557e752382d777181&chksm=bd2d031a8a5a8a0c6f7b58b79ae8933dfefbd840dfb5d34a5c708ab63e6decbbc1b13533ebc8&scene=21#wechat_redirect)

1. 基础规范
    1. 表存储引擎必须使用InnoDB，表字符集默认使用utf8，必要时候使用utf8mb4
    （1）通用，无乱码风险，汉字3字节，英文1字节
    （2）utf8mb4是utf8的超集，有存储4字节例如表情符号时，使用它
    2. 禁止使用存储过程，视图，触发器，Event
    3. 禁止在数据库中存储大文件，例如照片，可以将大文件存储在对象存储系统，数据库中存储路径
    4. 禁止在线上环境做数据库压力测试
    5. 测试，开发，线上数据库环境必须隔离
    
2. 命名规范
    1. 库名，表名，列名必须用小写，采用下划线分隔
    2. 库名，表名，列名必须见名知义，长度不要超过32字符
    3. 库备份必须以bak为前缀，以日期为后缀
    4. 从库必须以-s为后缀
    5. 备库必须以-ss为后缀
    
3. 表设计规范
    1. 单实例表个数必须控制在2000个以内
    2. 单表分表个数必须控制在1024个以内
    3. 表必须有主键，推荐使用UNSIGNED整数为主键
    4. 禁止使用外键，如果要保证完整性，应由应用程式实现
    5. 建议将大字段，访问频度低的字段拆分到单独的表中存储，分离冷热数据
    
4. 列设计规范
    1. 根据业务区分使用tinyint/int/bigint，分别会占用1/4/8字节
    2. 根据业务区分使用char/varchar
        （1）字段长度固定，或者长度近似的业务场景，适合使用char，能够减少碎片，查询性能高
        （2）字段长度相差较大，或者更新较少的业务场景，适合使用varchar，能够减少空间
    3. 根据业务区分使用datetime/timestamp
        前者占用5个字节，后者占用4个字节，存储年使用YEAR，存储日期使用DATE，存储时间使用datetime
    4. 必须把字段定义为NOT NULL并设默认值
        （1）NULL的列使用索引，索引统计，值都更加复杂，MySQL更难优化
        （2）NULL需要更多的存储空间
        （3）NULL只能采用IS NULL或者IS NOT NULL，而在=/!=/in/not in时有大坑
    5. 使用INT UNSIGNED存储IPv4，不要用char(15)
    6. 使用varchar(20)存储手机号，不要使用整数
        （1）牵扯到国家代号，可能出现+/-/()等字符，例如+86
        （2）手机号不会用来做数学运算
        （3）varchar可以模糊查询，例如like ‘138%’
    7. 使用TINYINT来代替ENUM
   
5. 索引规范
    1. 唯一索引使用uniq_[字段名]来命名
    2. 非唯一索引使用idx_[字段名]来命名
    3. 单张表索引数量建议控制在5个以内
        （1）互联网高并发业务，太多索引会影响写性能
        （2）生成执行计划时，如果索引太多，会降低性能，并可能导致MySQL选择不到最优索引
        （3）异常复杂的查询需求，可以选择ES等更为适合的方式存储
    4. 组合索引字段数不建议超过5个
    5. 不建议在频繁更新的字段上建立索引
    6. 非必要不要进行JOIN查询，如果要进行JOIN查询，被JOIN的字段必须类型相同，并建立索引
        因为JOIN字段类型不一致，而导致全表扫描
    7. 理解组合索引最左前缀原则，避免重复建设索引，如果建立了(a,b,c)，相当于建立了(a), (a,b), (a,b,c)
    
6. SQL规范
    1. 禁止使用 `select *`，只获取必要字段
       - `select * `会增加cpu/io/内存/带宽的消耗
       - 指定字段能有效利用索引覆盖
       - 指定字段查询，在表结构变更时，能保证对应用程序无影响
    2. insert必须指定字段，禁止使用insert into T values()
    3. 隐式类型转换会使索引失效，导致全表扫描
    4. 禁止在where条件列使用函数或者表达式
    5. 禁止负向查询以及%开头的模糊查询
    6. 禁止大表JOIN和子查询
    7. 同一个字段上的OR必须改写问IN，IN的值必须少于50个
    8. 应用程序必须捕获SQL异常

## 优化
1. 应尽量避免在 where 子句中使用 函数 或 `!=`, `<>`操作符，否则将引擎放弃使用索引而进行全表扫描
2. 避免隐式类型转换
3. 少用子查询,最好是把连接拆开成较小的几个部分逐个顺序执行
4. or 的查询尽量用 union或者union all 代替 (在确认没有重复数据或者不用剔除重复数据时，union all会更好)
5. 合理的增加冗余的字段（减少表的联接查询）
6. 适当建立索引

## 索引
> 索引是帮助 MySQL 高效获取数据的数据结构。我们可以简单理解为：快速查找排好序的一种数据结构。
> 
> Mysql 索引主要有两种结构：B+Tree 索引和 Hash 索引。

以 B-Tree 为结构的索引是最常见的索引类型，比如 InnoDB 和 MyISAM 都是以 B-Tree 为索引结构的索引，事实上是以 B+ Tree 为索引结构，B-Tree 和 B+Tree 区别在于，B+ Tree 在叶子节点上增加了顺序访问指针，方便叶子节点的范围遍历.

### 聚簇索引和非聚簇索引的区别
参考：[一分钟了解索引技巧](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651960258&idx=1&sn=caf8295fa5c0ee47d6b9e6bf5cffcb49&chksm=bd2d061e8a5a8f08374ddc84a3c59355368b840ab38ba97782947e02c0d9d6d3c289032b3d39&scene=25#wechat_redirect)
聚簇索引的叶节点就是数据节点，而非聚簇索引的页节点仍然是索引检点，并保留一个链接指向对应数据块。

## 数据库设计范式
1. 第一范式：无重复的列
字段值具有原子性,不能再分(**所有关系型数据库系统都满足第一范式**)
> 在任何一个关系数据库中，第一范式（1NF）是对关系模式的基本要求，不满足第一范式（1NF）的数据库就不是关系数据库。 所谓第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。如果出现重复的属性，就可能需要定义一个新的实体，新的实体由重复的属性构成，新实体与原实体之间为一对多关系。在第一范式（1NF）中表的每一行只包含一个实例的信息。

2. 第二范式：非主属性非部分依赖于主关键字
一个表必须有主键,即每行数据都能被唯一的区分
>第二范式（2NF）是在第一范式（1NF）的基础上建立起来的，即满足第二范式（2NF）必须先满足第一范式（1NF）。第二范式（2NF）要求数据库表中的每个实例或行必须可以被惟一地区分。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识。这个惟一属性列被称为主关键字或主键、主码。 第二范式（2NF）要求实体的属性完全依赖于主关键字。所谓完全依赖是指不能存在仅依赖主关键字一部分的属性，如果存在，那么这个属性和主关键字的这一部分应该分离出来形成一个新的实体，新实体与原实体之间是一对多的关系。为实现区分通常需要为表加上一个列，以存储各个实例的惟一标识

3. 第三范式：属性不依赖于其它非主属性 (消除冗余)
一个表中不能包涵其他相关表中非关键字段的信息,即数据表不能有沉余字段
> 满足第三范式（3NF）必须先满足第二范式（2NF）。简而言之，第三范式（3NF）要求一个数据库表中不包含已在其它表中已包含的非主关键字信息。例如，存在一个部门信息表，其中每个部门有部门编号（dept_id）、部门名称、部门简介等信息。那么在员工信息表中列出部门编号后就不能再将部门名称、部门简介等与部门有关的信息再加入员工信息表中。如果不存在部门信息表，则根据第三范式（3NF）也应该构建它，否则就会有大量的数据冗余


## 视图的作用，视图可以更改吗
视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。

视图不能被索引，也不能有关联的触发器或默认值，如果视图本身内有order by 则对视图再次order by将被覆盖。

创建视图：create view XXX as XXXXXXXXXXXXXX;

对于某些视图比如未使用联结子查询分组聚集函数Distinct Union等，是可以对其更新的，对视图的更新将对基表进行更新；但是视图主要用于简化检索，保护数据，并不用于更新，而且大部分视图都不可以更新。

## MySQL 锁
参考： [MySQL 锁机制](https://www.jianshu.com/p/0d5b7cd592f9)
### InnoDB 的行锁模式及加锁方法
InnoDB 的行锁有两种：共享锁（S）和排他锁（X）。为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁：意向共享锁和意向排他锁，这两种意向锁都是表锁。一个事务在给数据行加锁之前必须先取得对应表对应的意向锁

**InnoDB 行锁是通过给索引上的索引项加锁来实现的**

> 1. 只有通过索引条件检索数据，InnoDB才使用行级锁，否则会自动锁全表
> 2. 两个事务不能锁同一个索引
> 3. insert ，delete ， update 在事务中都会自动默认加上排它锁

### InnoDB什么时候使用表锁
1. 第一种情况是：事务需要更新大部分或全部数据，表又比较大，如果使用默认的行锁，不仅这个事务执行效率低，而且可能造成其他事务长时间锁等待和锁冲突，这种情况下可以考虑使用表锁来提高该事务的执行速度。
2. 第二种情况是：事务涉及多个表，比较复杂，很可能引起死锁，造成大量事务回滚。这种情况也可以考虑一次性锁定事务涉及的表，从而避免死锁、减少数据库因事务回滚带来的开销。

### InnoDB使用表锁注意事项
1. 使用LOCK TABLES虽然可以给InnoDB加表级锁，但必须说明的是，表锁不是由InnoDB存储引擎层管理的，而是由其上一层──MySQL Server负责的，仅当autocommit=0、innodb_table_locks=1（默认设置）时，InnoDB层才能知道MySQL加的表锁，MySQL Server也才能感知InnoDB加的行锁，这种情况下，InnoDB才能自动识别涉及表级锁的死锁；否则，InnoDB将无法自动检测并处理这种死锁。
2. 在用 LOCK TABLES对InnoDB表加锁时要注意，要将AUTOCOMMIT设为0，否则MySQL不会给表加锁；事务结束前，不要用UNLOCK TABLES释放表锁，因为UNLOCK TABLES会隐含地提交事务；COMMIT或ROLLBACK并不能释放用LOCK TABLES加的表级锁，必须用UNLOCK TABLES释放表锁。

### MyISAM 表锁
1. 共享读锁（S）之间是兼容的，但共享读锁（S）和排他写锁（X）之间，以及排他写锁之间（X）是互斥的，也就是说读和写是串行的。
2. 在一定条件下，ＭyISAM 允许查询和插入并发执行，我们可以利用这一点来解决应用中对同一表和插入的锁争用问题。
3. ＭyISAM 默认的锁调度机制是写优先，这并不一定适合所有应用，用户可以通过设置 LOW_PRIPORITY_UPDATES 参数，或在 INSERT、UPDATE、DELETE 语句中指定 LOW_PRIORITY 选项来调节读写锁的争用。
4. 由于表锁的锁定粒度大，读写之间又是串行的，因此，如果更新操作较多，ＭyISAM 表可能会出现严重的锁等待，可以考虑采用 InnoDB 表来减少锁冲突。

### MySQL 死锁
#### 产生原因
1. 竞争资源
    - 产生死锁中的竞争资源之一指的是竞争不可剥夺资源 [当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等]（例如：系统中只有一台打印机，可供进程 P1 使用，假定 P1 已占用了打印机，若 P2 继续要求打印机打印将阻塞）
    - 产生死锁中的竞争资源另外一种资源指的是竞争临时资源 [指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU 和主存均属于可剥夺性资源] （临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁

2. 进程间推进顺序非法
    - 若 P1 保持了资源 R1,P2 保持了资源 R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁
    
#### 产生死锁的必要条件
- 互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。
- 请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。
- 不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。
- 环路等待条件：在发生死锁时，必然存在一个进程--资源的环形链。

#### 预防死锁
- 资源一次性分配：一次性分配所有资源，这样就不会再有请求了：（破坏请求条件）
- 只要有一个资源得不到分配，也不给这个进程分配其他的资源：（破坏请保持条件）
- 可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）
- 资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）
    
#### 解除死锁
- 剥夺资源：从其它进程剥夺足够数量的资源给死锁进程，以解除死锁状态；
- 撤消进程：可以直接撤消死锁进程或撤消代价最小的进程，直至有足够的资源可用，死锁状态。消除为止；所谓代价是指优先级、运行代价、进程的重要性和价值等。

## InnoDB && MyISAM
![1571550003580.jpg](../images/1571550003580.jpg)

## MySQL 的基础架构
`MySQL` 是一种关系数据库产品，是建立在关系模型基础上的数据库。架构一般可分为 **应用层** ，**逻辑层**，**物理层**
- 应用层 ： 负责和客户端以及用户进行交互
- 逻辑层 ： 负责具体的查询处理，事物管理，存储管理，恢复管理等
- 物理层 ： 磁盘上的数据库文件（存储文件，日志文件等）

## MySQL 常用存储引擎比较
> 查看MySQL的默认存储引擎 `show variables like '%storage_engine%'`

（1）： MyISAM 存储引擎
不支持事务、也不支持外键，优势是访问速度快，对事务完整性没有 要求或者以 select， insert 为主的应用基本上可以用这个引擎来创建表
支持3种不同的存储格式，分别是：**静态表**； **动态表**； **压缩表**
- **静态表**： 表中的字段都是非变长字段，这样每个记录都是固定长度的，优点存储非常迅速，容易缓存，出现故障容易恢复；缺点是占用的空间通常比动态表多（因为存储时会按照列的宽度定义补足空格）ps：在取数据的时候，默认会把字段后面的空格去掉，如果不注意会把数据本身带的空格也会忽略。
- **动态表**： 记录不是固定长度的，这样存储的优点是占用的空间相对较少；缺点：频繁的更新、删除数据容易产生碎片，需要定期执行OPTIMIZE TABLE或者myisamchk-r命令来改善性能
- **压缩表**： 因为每个记录是被单独压缩的，所以只有非常小的访问开支
MyISAM 的表存储成3个文件。文件的名字与表名相同。拓展名为frm、MYD、MYI。其实，frm文件存储表的结构；MYD文件存储数据，是MYData的缩写；MYI文件存储索引，是MYIndex的缩写。
MyISAM：只支持表级锁，只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁。

（2）： InnoDB 存储引擎
该存储引擎提供了具有提交、回滚和崩溃恢复能力的事务安全。但是对比MyISAM引擎，写的处理效率会差一些，并且会占用更多的磁盘空间以保留数据和索引。
InnoDB存储引擎的特点：支持**自动增长列**，**支持外键约束**，**支持事务**
InnoDB中，创建的表的表结构存储在 **.frm** 文件中， 数据和索引存储在 innodb_data_home_dir 和 innodb_data_file_path 定义的表空间中
InnoDB：支持**事务**和**行级锁**，是 innodb 的最大特色。行锁大幅度提高了多用户并发操作的新能。

总结：
- InnoDB： MySQL版本大于5.5时的默认引擎 适用于读少，写多以及高并发场景
    + 灾难恢复性好
    + 支持全部的事物[隔离级别](#事物的隔离级别)
    + 使用行级锁
    + 支持外键
    + 不支持全文索引 （全文索引可以使用**Sphinx**，**ElasticSearch**）
    + 按行删除
    
- MyISAM： 适用于读多，写少对原子性要求低的场景
    + 支持全文索引
    + 单独维护索引文件(MYI)
    + 不支持事物
    + 不支持外键
    + 只支持表级锁
    + 可以被压缩，存储空间小
    + 删除时会先删除表，然后重新建立表结构

## 索引比较 
>[1分钟了解MyISAM与InnoDB的索引差异](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651961494&idx=1&sn=34f1874c1e36c2bc8ab9f74af6546ec5&chksm=bd2d0d4a8a5a845c566006efce0831e610604a43279aab03e0a6dde9422b63944e908fcc6c05&scene=21#wechat_redirect)

总结:
* MyISAM的索引与数据分开存储
* MyISAM的索引叶子存储指针，主键索引与普通索引无太大区别
* InnoDB的聚集索引和数据行统一存储
* InnoDB的聚集索引存储数据行本身，普通索引存储主键
* InnoDB一定有且只有一个聚集索引
* InnoDB建议使用趋势递增整数作为PK，而不宜使用较长的列作为PK

### 关于索引
> [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)

- 数据库索引用于加速查询
- 虽然哈希索引是O(1)，树索引是O(log(n))，但SQL有很多“有序”需求，故数据库使用树型索引，InnoDB不支持哈希索引
- 数据预读的思路是：磁盘读写并不是按需读取，而是按页预读，一次会读一页的数据，每次加载更多的数据，以便未来减少磁盘IO
- 局部性原理：软件设计要尽量遵循“数据读取集中”与“使用到一个数据，大概率会使用其附近的数据”，这样磁盘预读能充分提高磁盘 IO

#### B+ 树索引
- 很适合磁盘存储，能够充分利用局部性原理，磁盘预读
- 很低的树高度，能够存储大量数据
- 索引本身占用的内存很小
- 能够很好的支持单点查询，范围查询，有序性查询

## 事物
### 事物的基本特性(ACID)
1. 原子性`Atomicity`： 事物开始后的所有操作要么回退，要么提交，不会停留在中间的某个部分，类似于化学中的原子，构成物质的最基本单位
2. 一致性`Consistency`： 事务开始前和结束后，数据库的完整性约束没有被破坏
3. 隔离性`Isolation`： 同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰
4. 持久性`Durability`： 事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚

### 事物的隔离级别
|事物的隔离级别|脏读|不可重复度|幻读|
|--|--|--|--|
|读未提交`Read Uncommitted`| 是 | 是 | 是 |
|读提交`Read Committed` | 否 | 是 | 是 |
|可重复读`Repeated Read` (默认) | 否 | 否 | 是 |
|串行化`Serializable` | 否 | 否 | 否 |
> 设置当前事务模式为读提交: `set session transaction isolation level read committed`;

总结：
- 并发事务之间相互干扰，可能导致事务出现读脏，不可重复度，幻读等问题
- **InnoDB** 实现了 [SQL92](https://baike.baidu.com/item/SQL92) 标准中的四种隔离级别
    * 读未提交: select 不加锁，可能出现 **脏读**
    * 读提交(RC): 普通 select 快照读，锁 select / update / delete 会使用记录锁，可能出现 **不可重复读**
    * 可重复读(RR): 普通 select 快照读，锁 select / update / delete 根据查询条件情况，会选择记录锁，或者 间隙锁 / 临键锁，以防止读取到幻影记录 (**幻读**)
    * 串行化: select 隐式转化为 select ... in share mode，会被 update 与 delete 互斥
- InnoDB默认的隔离级别是 **RR**(Repeated Read)，用得最多的隔离级别是 **RC**(Read Committed)

## Explain 详解
参考 ： [MySQL EXPLAIN详解](https://www.jianshu.com/p/ea3fc71fdc45)

|列名|说明|
|--|--|
|id|执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置|
|select_type|显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT）|
|table|访问引用哪个表|
|type|数据访问/读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL）|
|possible_keys|揭示哪一些索引可能有利于高效的查找|
|key|显示mysql决定采用哪个索引来优化查询|
|key_len|显示mysql在索引里使用的字节数|
|ref|显示了之前的表在key列记录的索引中查找值所用的列或常量|
|rows|为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数|
|Extra|额外信息，如using index、filesort等|

### Explain:id
id是用来顺序标识整个查询中SELELCT 语句的，在嵌套查询中id越大的语句越先执行。该值可能为NULL

### Explain:select_type
表示查询的类型

|类型|说明|
|--|--|
|simple|简单子查询，不包含子查询和union|
|primary|包含union或者子查询，最外层的部分标记为primary|
|subquery|一般子查询中的子查询被标记为subquery，也就是位于select列表中的查询|
|derived|派生表——该临时表是从子查询派生出来的，位于form中的子查询|
|union|位于union中第二个及其以后的子查询被标记为union，第一个就被标记为primary如果是union位于from中则标记为derived|
|union result|用来从匿名临时表里检索结果的select被标记为union result|
|dependent union|顾名思义，首先需要满足UNION的条件，及UNION中第二个以及后面的SELECT语句，同时该语句依赖外部的查询|
|subquery|子查询中第一个SELECT语句|
|dependent subquery|和DEPENDENT UNION相对UNION一样|

### Explain:table
对应行正在访问哪一个表，表名或者别名
- 关联优化器会为查询选择关联顺序，左侧深度优先
- 当from中有子查询的时候，表名是derivedN的形式，N指向子查询，也就是explain结果中的下一列
- 当有union result的时候，表名是union 1,2等的形式，1,2表示参与union的query id

### Explain:type
type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref

|类型|说明|
|--|--|
|All|最坏的情况,全表扫描|
|index|和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。如在Extra列看到Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多|
|range|范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用=、 <>、>、>=、<、<=、IS NULL、<=>、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可以使用 range|
|ref|一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟eq_ref不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是UNIQUE和PRIMARY KEY。ref可以用于使用=或<=>操作符的带索引的列。|
|eq_ref|最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效）|
|const|当确定最多只会有一行匹配的时候，MySQL优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入where子句时，mysql把这个查询转为一个常量（高效）|
|system|这是const连接类型的一种特例，表仅有一行满足条件。|
|Null|意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效）|

### Explain:possible_keys
显示查询使用了哪些索引，表示该索引可以进行高效地查找，但是列出来的索引对于后续优化过程可能是没有用的

### Explain:key
key列显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX

### Explain:key_len
key_len列显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好

### Explain:ref
ref列显示使用哪个列或常数与key一起从表中选择行

### Explain:rows
rows列显示MySQL认为它执行查询时必须检查的行数。注意这是一个预估值

### Explain:Extra
Extra是EXPLAIN输出中另外一个很重要的列，该列显示MySQL在查询过程中的一些详细信息，MySQL查询优化器执行查询的过程中对查询计划的重要补充信息

|类型|说明|
|--|--|
|Using filesort|MySQL有两种方式可以生成有序的结果，通过排序操作或者使用索引，当Extra中出现了Using filesort 说明MySQL使用了后者，但注意虽然叫filesort但并不是说明就是用了文件来进行排序，只要可能排序都是在内存里完成的。大部分情况下利用索引排序更快，所以一般这时也要考虑优化查询了。使用文件完成排序操作，这是可能是ordery by，group by语句的结果，这可能是一个CPU密集型的过程，可以通过选择合适的索引来改进性能，用索引来为查询结果排序。|
|Using temporary|用临时表保存中间结果，常用于GROUP BY 和 ORDER BY操作中，一般看到它说明查询需要优化了，就算避免不了临时表的使用也要尽量避免硬盘临时表的使用。|
|Not exists|MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行， 就不再搜索了。|
|Using index|说明查询是覆盖了索引的，不需要读取数据文件，从索引树（索引文件）中即可获得信息。如果同时出现using where，表明索引被用来执行索引键值的查找，没有using where，表明索引用来读取数据而非执行查找动作。这是MySQL服务层完成的，但无需再回表查询记录。|
|Using index condition|这是MySQL 5.6出来的新特性，叫做“索引条件推送”。简单说一点就是MySQL原来在索引上是不能执行如like这样的操作的，但是现在可以了，这样减少了不必要的IO操作，但是只能用在二级索引上。|
|Using where|使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。注意：Extra列出现Using where表示MySQL服务器将存储引擎返回服务层以后再应用WHERE条件过滤。|
|Using join buffer|使用了连接缓存：Block Nested Loop，连接算法是块嵌套循环连接;Batched Key Access，连接算法是批量索引连接|
|impossible where|where子句的值总是false，不能用来获取任何元组|
|select tables optimized away|在没有GROUP BY子句的情况下，基于索引优化MIN/MAX操作，或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。|
|distinct|优化distinct操作，在找到第一匹配的元组后即停止找同样值的动作|

## Other
### **InnoDB** 的七种锁
```log
1. 共享/排它锁   Shared and Exclusive Locks
2. 意向锁       Intention Locks
3. 记录锁       Record Locks
4. 间隙锁       Gap Locks
5. 临键锁       Next-key Locks
6. 插入意向锁    Insert Intention Locks
7. 自增锁       Auto-inc Locks
```

### MySQL 的常见优化
#### 常见优化
- 构建SQL时应避免全表扫描
- 建立索引 (先应考虑在 **where** 及 **order by** 涉及的列上建立索引)
- 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理
- 尽量避免大事务操作，提高系统并发能力
- 应尽量避免在 where 子句中使用 **!=** 或 `<>` 操作符，否则将引擎放弃使用索引而进行全表扫描
- 使用 **in** 来代替 **between**
- 使用 **union all** 来代替 **or**
- 避免类型转换（查询的类型要与字段的类型一致）
- 尽量不使用 **NOT IN** 和 `<>`
- 除非必要的条件下 **事物** 可以使用锁表来代替

#### 索引命中
**在以下场景中MySQL不会使用索引**
- 使用 **NOT IN** 、 **!=** 以及 `<>` 不等于的时候
- 在 **join** 时条件字段类型不一致的时候
- 以 **%** 开头 的 **like** 查询
- 使用 **or** 的时候， **or** 的前后字段中存在没有索引的情况时
- 在组合索引里使用非第一个索引字段时也不使用索引

### MySQL B+Tree 演示
点击直达： https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html